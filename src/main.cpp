#include <iostream>
#include <vector>
#include <fstream>
#include <map>
#include <stack>
#include <set>

#include "osnove.h"
#include "../sequences/sequences.h"
#include "osnove.h"
#include "gradi.h"

#include <bioparser/bioparser.hpp>

namespace hera {

    uint32_t MinMCPaths, HardNodeLimit, SoftNodeLimit;
    uint32_t NumDFSNodes, MaxMCIterations;
    uint32_t MinPathsinGroup;
    float SImin, OHmax;

    bool test_short_length, test_contained_reads, test_low_quality;
    bool print_output;
    double PathGroupHalfSize;

    std::string logFile;

}

void postavi_pocetne_parametre() {

    // A minimum number of paths generated by Monte Carlo method
    hera::MinMCPaths = 40;
    // A maximum number of nodes that a path can contain, longer paths will not be generated
    hera::HardNodeLimit = 1000;
    // A number of nodes in a path that will cause a warning to be displayed
    hera::SoftNodeLimit = 100;

    // A number of nodes added to the stack in each step of DFS graph traversal
    hera::NumDFSNodes = 5;
    // Maximum number of iterations using Monte Carlo approach
    hera::MaxMCIterations = 100000;

    // A minimum number of paths in a group that will generate a scaffold
    hera::MinPathsinGroup = 3;

    // Minimum sequence identity for filtering overlaps
    hera::SImin = 0.60;
    // Maximum allowed overhang percentage for filtering overlaps
    hera::OHmax = 0.25;

    hera::test_short_length = true;
    hera::test_contained_reads = true;
    hera::test_low_quality = true;

    // A path is placed in a group if its length falls within pathGtoupHalfSize of groups representative length
    hera::PathGroupHalfSize = 5000;

    hera::print_output = true;

    // Setting Log file
    hera::logFile = "output.txt";
}


/**
 * run:
 * ./hera kontizi.fasta ocitanja.fasta ovlpKontOcit.pff ovlpOcitOcit.paf
 * */

int main(int argc, char* argv[]) {
    // std::cout << "In principio erat Verbum" << std::endl;

    // argumenti
    std::string kontizi = argv[1]; // FASTA format
    std::string ocitanja = argv[2]; // FASTA ili FASTQ format
    std::string preklapanja_kontizi_ocitanja = argv[3]; // PAF format
    std::string preklapanja_ocitanja_ocitanja = argv[4]; // PAF format

    // tu ubaciti ostale parametre ak bude potrebno
    postavi_pocetne_parametre();

    hera::SBridger sbridger(ocitanja, kontizi, preklapanja_ocitanja_ocitanja, preklapanja_kontizi_ocitanja);
    
    sbridger.generateGraph();

    int broj_staza = sbridger.generatePaths();

    // sbridger.printPaths();

    int broj_grupa = sbridger.groupAndProcessPaths();

    int broj_sekvenci = sbridger.generateSequences();


    std::cout << std::endl;

    std::cout << "broj sekvenci: " <<    broj_sekvenci << std::endl;


    return 0;
}
